# 程序员的惊喜桌面

**假如说**你有了心上人，想用程序向她吐露真情  
或许人家早就有了男朋友，但你还是想在空闲的时候在电脑屏幕上领略她的美貌  
或许你就只不过是老二次元/嘉心糖，想把他们的头像作为屏幕保护……

利用Qt对图像显示的API，打开程序，可以自己选定的图片就会展现在桌面。  
再加点鼠标事件、加点动画效果，发给心上人，给她代码码出来的惊喜。

![Demo](DemoImages/Demo.png)

# 前置知识

## 半小时学会Qt可能吗？

首先恭喜你们成功完成C语言的课程——  
C语言就学了一学期，Qt C++这么复杂，怎么可能？

（个人认为）编程学习有两种：学习特性与学习函数用法。  
比如说指针属于“特性”，不使用指针，写不出来“指向一个东西”的功能。  
而`fopen`之类的函数，其实是C语言库开发者用C语言的其他功能实现的。

给你一段关于指针的描述，很难看懂指针是什么。但只要对着`fopen`函数的用法，大概就能用它打开一个文件。

Qt是一个使用C++编写的第三方**库**，比起指针这种语言核心特性更像是函数的集合。  
所以这半小时讲的是如下内容：

- Qt Widgets桌面部件的结构（特性）
- Qt `QObject`信号与槽系统（特性）
- 如何利用Qt官方文档，自己学会使用一个Qt类/函数

## `QObject`的树结构

### 第一个Qt Widgets程序

创建一个Qt Widget工程。放哪里都行，只是演示用。工程类型选Qt Widgets Application  
一路点Next，会发现创建了很多文件，很吓人。但不用怕，先把`main.cpp`*全部*注释，粘贴下面的代码：

```c++
#include <QtWidgets/QApplication>
#include <QtWidgets/QLabel> // QLabel是一个显示文本的部件类

int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    QLabel l(nullptr);
    l.setText("Hello World!"); // 设置文本
    l.show(); // 显示标签
    return a.exec();
}
```

运行。出现Hello World。现在有两个问题：

- `nullptr`是干什么的？
- 我们的程序只能显示这一个部件吗？

### Qt Widgets的部件结构

`QObject`的一个特点是可以建立子对象。  
子对象“属于”父对象，对父对象操作时，子对象也会做出相应动作。  
对象可以有很多子对象，但只能有一个父对象。  

```c++
class QObject {
    QObject *parent;
    QObjectList children;
    ......
};
```

每一个窗口也是`QObject`。复杂的窗口的部件树长这样：

![WidgetTree图片还没画😳](DemoImages/WidgetTree.png)

### 子部件程序

回到`main.cpp`做如下修改：

```c++
#include <QtWidgets/QApplication>
#include <QtWidgets/QLabel>
#include <QtWidgets/QPushButton>

int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    QWidget* w = new QWidget(nullptr);
    QLabel* l = new QLabel(w);
    QPushButton* p = new QPushButton(w);

    l->setGeometry(0,0,50,50);
    l->setText("I am Label!");
    p->setGeometry(200,200,200,200);
    p->setText("Hide Label!");
    w->show(); l->show(); p->show();

    QObject::connect(p, &QPushButton::clicked, l, &QWidget::hide);
    int ret = a.exec();
    delete p; delete w;
    return ret;
}
```

运行查看效果。  
注意这里使用了指针与new运算符。new运算符代表创建一个对象，delete运算符销毁它。  
C语言里讲`malloc`时，老师一定费劲地喊：  

> `malloc`分配的内存一定要使用`free`释放！否则内存泄漏！！

但是我们三个new只有两个delete，怎么回事啊？  
这就是Qt的神力，父对象删除会自动删除子对象。  
删除子对象时，会自动把它从树结构里剔除  
**Qt对象都使用指针和new的方式创建，而delete可以在设定父子关系后由Qt自己处理**  
> 有些同学学完Qt树结构后，认为“只要在使用Qt，就不需要管delete了”。注意只有具有父子关系时才会自动释放。  
> 比如如果写`QLabel* l = new QLabel(nullptr)`，那么l必须手动删除，删除w和它没有半毛钱关系。  
> 值得一提的是，前面的例子没有使用指针和new。原因是十分进阶的内容，很难理解，先记着吧😭

### 放在类里面(视频里面有讲)

如果我们把所有部件一股脑放进`main`函数，很快就脏乱不堪了  
更重要的是，如果你创造了一个有一定功能的部件，是否要复制粘贴一遍创建的代码呢？

依靠C++的继承系统，我们可以把这个有功能的部件抽象为一个新的类，  
由于它**是**一个部件，因此它需要**继承**于部件类`QWidget`  
比如框架的`imgItem`类，它以一定旋转角度展示图片（功能）。  
这样只要一行代码创建这个类的对象，它的所有功能就能使用了。

实际上，有个叫做`Qt Designer`的东西能够方便创建部件的子类：只需要鼠标拖动，不需写代码。  
但是：

1. Designer生成的代码使用了很多技巧，一眼看过去很难懂（d指针、多国语言翻译，布局……）
2. 很多新人接触之后迷上了Designer，忽视了其他地方的学习
3. *`Qt Designer`生成的界面是静态的，即生成后的界面很少改动。*  
而我们的子部件一会出现一会消失，还有旋转等等，不能使用这种方式。

下学期开课会具体讲`Qt Designer`，现在先放着吧\[笑哭\]

## 事件处理

### 信号与槽（视频里面有）

```c++
QObject::connect(p, &QPushButton::clicked, w, &QWidget::hide);
QObject::connect(p, &QPushButton::clicked, [&, timeClick = 0U] () mutable {
    lbl->setText(QString::number(++timeClick));
});
```

（常用的）`connect`函数有上面两种。第一个参数都是信号发送者，第二个是发送的信号。  
如上两种代表的都是按钮p被点击。  
后面的参数，一种是接受者与槽函数，另一种是一个单独的函数。  

为什么要分两种呢？  
第一种看起来比较正常：按钮p点击，部件w隐藏。但这种的一个致命缺陷是，两个函数参数必须类型一致。  
如果要做的不是隐藏而是改变标签文字，就只能使用第二种方法——自己定义一个参数类型一致的函数。

### `QEvent`与`QWidget::event`虚函数

除了信号与槽外，Qt还内置了一些事件，例如点击鼠标、敲击键盘、界面放大等。  
每当事件发生，一个叫做`event`的虚函数会被调用。  
如果需要这些底层事件处理，需要重写`event`函数而不是使用信号与槽，用到了可以上网搜索。

## 模板库基础(STL)

注：这里假定C语言讲过链表。若大多数不会可以大概讲一下，包括：  
直接插入/删除，无法直接访问元素

### 迭代器——广义的指针

通过迭代器的封装，类似链表这种需要节点指针的结构，甚至是任何一种结构，  
在用户手里都可以以`++ --`这样的方式遍历  
哪怕你对链表一窍不通，都能利用迭代器访问它。  

### 双向迭代器与随机访问迭代器

指针可以自增自减，可以进行加法减法运算。在学习数组的时候经常使用。  
但遗憾的是，对于数组，我们想获得第5个元素地址，只要指针加5,  
而链表需要一个一个前进，无法+5,所以迭代器不一定有指针的所有操作。

C++里依据这种特性，定义了*迭代器的分类*。在这里介绍两种：  
双向迭代器，对应链表的迭代器（可以前后移动，但无法跳着访问）
随机访问迭代器，对应数组的迭代器（可以跳着访问）
> 此外还有输入迭代器、输出迭代器、前向迭代器（单链表）、连续迭代器（C++20）  
> 感兴趣的还可以搜索`begin` `end`函数

迭代器种类说明访问操作的效率。数组的迭代器是随机访问的指针，可以在常数时间访问任意元素。  
链表的迭代器是双向的，意味着可以访问一个元素的前后元素，但必须“一个个走过去”。  
> 文件系统迭代器是前向的，意味着访问下一个元素后就回不去了，只能向再下一个前进。

### 就地构造

`emplace` vs `insert`  
有一个数组，现在需要在后面加入元素。怎么办？  
方案1 在主函数里构造一个元素，然后移动到数组尾部  
方案2 直接跑到数组尾部，构造元素  

对于C语言，两种方案没有差距。但注意，在C++里，*不是所有东西都能移动的*，即使能，移动函数是有可能十分复杂的。  
因此在C++里，需要*构造元素并放入容器*的时候使用的是`emplace`就地插入  
> 但是如果插入的对象不是才构造的，仍然使用`insert`

# 我们的程序

现在有一个基本的程序框架，这个毛坯程序从应用所在目录的Images目录里读取图片，  
每0.3秒随机抽取一张，随机旋转一定角度展示。如果桌面展示的图片数量超过10个，  
以*先进先出*（队列）的原则销毁多余的再放一个。

## 部件结构

仔细观察程序演示，好像不需要任何子部件：把显示图片的部件摆上去似乎能行。  
但是这有严重问题：**没有父部件的部件是一个独立的窗口**。如果这样：  

- 只有*所有*窗口关闭，程序才停止。
- 任务栏会出现几十甚至上百个标签，想象一下同时打开100个Word文档的感觉

所以我们使用一个大部件，用于管理图片显示部件。  
显示一张图片的小部件叫做`imgItem` 总的大部件叫做`imgScene` 都继承最基本的部件`QWidget`  
考虑入门的特征，先设定只有两级部件且都是基本的`QWidget`。  
寒假自由发挥的时候可以加入更多种类/层级的部件，后面会说到。

## 内存占用问题

C语言老师可能强调过，在95%的情况下程序执行时间是很重要的，尽量以空间换时间。  
但这里恰好是那5%：

### 999张图片里显示10张

不要小看程序员——很多都是老二次元或老色皮了，他们的图片数量可不是你想象的。  
很有可能有数百MB的图片等待抽取。  
另外我们看到的图片都是压缩之后的，为了使旋转、渲染顺利进行，内存里的图片是解压了的。  
最终结果是，小小的桌面惊喜搞出来一个2GB内存占用……你的心上人用的老爷机，还没开始就抛出`std::bad_alloc`崩溃了。

### 10张图片里显示999张

你会想到：图片不要统一加载，渲染哪个就分配哪个。确实上面的问题解决了。  
但是，毛坯程序固定显示10张图片不代表你们的成品只有十张。  
100 1000 2000……密集牛逼症不会嫌弃的。  
另外，由于当新加入的图片与老的发生重叠时，老图片的渲染方法会被调用，因此不能把老图片渲染完一次就删掉，必须一直存储。  
显示器上的图片越来越多，在这种情况下，内存占用会再次达到2GB。

### 计数器

这里采用*引用计数*的方式，保证内存里一张图片只存有0或1份副本，  
当且仅当显示器上展示这一张图片，计数器非零，内存才存有这个副本。  
对于情况1，1000个计数器只有至多10个非0，存10份图片到内存  
对于情况2，10个计数器计数均很大，10份图片全部在内存存1份副本

> 有兴趣的同学可以了解一下智能指针`std::shared_ptr<>`的引用计数方式，  
> 思考为什么智能指针在这里不如手写引用计数  
> 智能指针是模板类，可以尝试着把图片计数器类模板化，在这里使用模板参数（之一）是`QPixmap`的实例化

## 存储方式的选择

我们有两组物品需要存储：图片显示部件以及图片本身  
对于图片本身，每一个显示部件都需要读取，但只在初始化和关闭的时候修改，  
读取多修改少，使用数组  

显示部件就不一样了：需要频繁的插入与删除。  
尤其是删除图片的时候，大量显示被删图片的部件全部要被删。  
并且由于**部件是不可移动的**，数组的插入无法使用。  
对于这个部件的存储，使用链表。

## 你们的任务（参考）

### 展示效果方面

1. 加入鼠标、键盘事件，动画效果等等
2. 演示里向日葵图片特别的大。仿照随机旋转制作随机缩放
3. 加入背景音乐、背景图片等，让你的心上人心动吧❤（安装Qt时需选择Qt Multimedia）
4. ……

### 功能方面

1. 添加更多关闭方法，不只是Alt F4与任务栏关闭
2. 添加选择显示图片数量、路径的方法(QFileDialog, QMenu...)
3. 添加配置文件、命令行参数等
4. ……

### 优化方面

这个程序有致命缺陷：打开后展示前，所有图片都会检查是否是有效图片。  
检查图片有效性不是一个简单的任务，比如有1000张图片，是需要一个个分配、判断、释放的。  
这样虽然内存看起来没有问题，实际上要消耗大量时间，断断续续分配释放一共数GB的内存。  
等到第一张图片出来时，你的心上人已经花儿都谢了。  
你的任务是在保证图片有效的前提下，把检测分散开，避免启动缓慢。

解决这个问题需要对内存分配深入理解。这也是C++的特色。只要解决了这一个问题，哪怕其他一概不做，都是极其优秀的作品。

## 活动目标与预期成效

1. 认识与类相关的堆内存分配策略，包括`new delete`，智能指针，掌握避免内存泄漏的方法
2. 掌握Qt父子部件的树结构存储，了解Qt内部对父子部件的交互
3. 了解迭代器设计的巧妙之处，认识双向与随机访问容器/迭代器的区别
4. 认识链表操作的特点，学会根据容器的使用情况选用合适的容器
5. 掌握“就地构造”的概念，会使用`emplace_back` `make_unique`等就地构造函数
6. 掌握一定的通过搜索引擎获取API函数用法、解决问题的能力
7. 学习编写模块化、面向对象的软件开发，能够处理有一定代码量的工程

> 有能力的同学可以尝试代码里提出的模板元编程任务。它远远比想象里的难，不做要求  
> 也可以学着使用git进行版本管理

如果完成的不错，

1. 对你们的干事考核很有帮助😀
2. 程序设计周保证单刷95

## 最后，千万别忘了神奇的F1哦

最后，千万别忘了神奇的帮助文档键F1哦  
最后，千万别忘了神奇的帮助文档键F1哦  
